## 一、编译原理

### 1.1 编译器与引擎

​		首先，我们来弄清楚，当我们敲完`var a = 2`，到编译器解析完成这段过程发生了什么。

​		作为一个程序猿，本能的回答是“为一个变量分配内存，将其命名为a，然后将值2保存进这个变量”。但这个回答并不完全正确。So，let's figure out what on earth happened during the process!

​	1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。

 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

    **小结**：变量的赋值操作会执行**两个动作**，首先编译器会在当前作用域中**声明一个变量**，然后在运行时引擎会**在作用域中查找该变量**，如果能够找到就会对它赋值。

    

### 1.2 LHS与RHS

  - RHS引用

    ​		你可以把它理解成**得到某某的值**。

    ​		举一个典型的例子：`console.log(a)` 。这其实就是对a的一个RHS引用，编译器需要查找并取得a的值，采后将值传给`console.log(...)`。

- LHS引用

  ​		你可以把它理解成简单的赋值即可。

  ​		举一个典型例子：`a = 2`（a已事先声明）。这是一个对a的LHS引用，a在赋值等式的左侧（与LHS中的L对应，即为left）。

- 引擎与作用域的对话（摘自《你不知道的JavaScript上卷》）

  ```javascript
  function foo(a) {
  console.log( a ); // 2
  }
  foo( 2 );
  ```

  >  让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。 
  >
  > 引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？ 
  >
  > 作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。 
  >
  > 引擎：哥们太够意思了！好吧，我来执行一下 foo。
  >
  > 引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？ 
  >
  > 作用域：这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。 
  >
  > 引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。 
  >
  > 引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？ 
  >
  > 作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。 
  >
  > 引擎：么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。 
  >
  > 引擎：哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。 
  >
  > 作用域：放心吧，这个变量没有变动过，拿走，不谢。 引擎：真棒。我来把 a 的值，也就是 2，传递进 log(..)。



### 1.3 作用域嵌套

​		这其实就和c语言的机制类似。如果当前作用域无法找不到某个变量的时候，引擎就会一层层往外找，直到找到这个变量，或者是抵达全局作用域。

```javascript
function foo(a){
    console.log(a+b);
}
var b = 2;
foo(2);			// 4
```

​		在上面这个例子，我们引用了foo这个函数（在执行过程中其实有一个对a的一个隐式LHS引用，a=2），在函数执行过程中，引擎发现在foo的作用域内找不到b这个变量，于是就往外找，在外面一层的作用域找到了b这个变量，对b进行了RHS引用。









## 二、函数作用域和块作用域

### 2.1 函数中的作用域

```javascript
function foo(a){
    var b = 2;
    function bar(){
        // some code
    }    
    var c = 3;
}
```

​		在这段代码中，foo函数的作用域气泡中包含有a，b，c，bar。在foo函数中，我们可以访问到这些标识（或者是变量），但是从函数外部，我们访问不到foo函数中的上述标识。

​		例如：我们在全局作用域中编写以下代码，会导致ReferenceError错误。

```javascript
bar();
console.log(a,b,c)
```

​		

### 2.2  函数声明与函数表达式

​		我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

```javascript
var a = 2;
function foo(){
    var a = 3;
    console.log(a);		//3
}
foo();
console.log(a);		//2
```

​		虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先， 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域。其次，必须显式地通过函数名（foo()）调用这个函数才能运行其 中的代码。下面提供一种用函数表达式的方法来解决这个问题。

> **区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**

```javascript
var a = 2;
(function foo(){
	var a = 3;
 	console.log(a+" 这里是foo函数中的a"); // 3 这里是foo函数中的a
})(); 
// 通过()把函数包起来，使得在全局作用域下不能访问得到
// 第二个()表示立即执行foo函数
console.log(a+" 这里是全局作用域下中的a"); // 2 这里是全局作用域下中的a
```

​		我们来解释一下这里发生了肾么事：在这个代码片段中foo函数被绑定在函数表达式自身的函数中而不是所在作用域中。(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。也就是说如果我们在全局作用域下执行这个函数，会导致**foo is not defined**的错误。



### 2.3 块作用域

​		先来看一段很常见的for循环代码：

```javascript
for (var i = 0; i < 10; i++){
  console.log(i + "这里是for循环中的i");
}

console.log(i + "这里是全局作用域下的i"); //10这里是全局作用域下的i
```

​		我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。

​		为什么要把一个只在 for 循环内部使用（至少是应该只在内部使用）的变量 i 污染到整个函数作用域中呢？



#### * let关键字

​		为了解决块作用域的问题，在ES6中引入了let关键字。

```javascript
for (let i = 0; i < 10; i++){
  console.log(i + "这里是for循环中的i");
}

console.log(i + "这里是全局作用域下的i");
// ReferenceError: i is not defined
```

​		这里我们用let代替var声明变量 i ，就将 i 限制在了for循环的这个块作用域中，因此我们不能从全局访问到 i 。

**注：但是使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不 “存在”。**



#### *const关键字

​		用const声明的变量不能改变变量的值。const声明的变量也是绑定在块作用域中。

```javascript
var foo = true;

if(foo){
  var a = 2;
  const b = 3;
  console.log("这里是var声明的a："+a);
  console.log("这里是const声明的b："+b);
  a = 3;
  b = 4;    //TypeError: Assignment to constant variable.
}

console.log(a);   // 3
console.log(b);   // ReferenceError!
```

